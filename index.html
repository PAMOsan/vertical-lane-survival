<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>Vertical Lane Survival - モバイル最適化（フルスクリーン利用・味方列改善）</title>
<style>
  html,body { height:100%; margin:0; background:#0b0b0b; color:#fff; font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; -webkit-tap-highlight-color: transparent; }
  body { padding-bottom: env(safe-area-inset-bottom, 0); box-sizing:border-box; }
  /* コンテナは画面幅いっぱいに使う（スマホで横幅を最大活用） */
  #container { width:100%; max-width:100vw; margin:6px auto; box-sizing:border-box; padding:0 6px; }
  #ui { display:flex; gap:8px; align-items:center; justify-content:space-between; margin-bottom:6px; }
  #gameWrap { position:relative; width:100%; }
  /* canvas は JS でサイズを決めるが CSS は幅100%で親に合わせる */
  #game { display:block; width:100%; background:#151515; border:3px solid #333; box-sizing:border-box; touch-action:none; border-radius:8px; }
  button { padding:6px 10px; background:#1f6feb; color:#fff; border:0; border-radius:6px; cursor:pointer; font-size:14px; }
  .info { font-size:13px; color:#ddd; line-height:1; }
  .hint { font-size:12px; color:#bbb; margin-top:6px; text-align:center; }
  /* CLEAR overlay（DOMで一つだけ表示） */
  #clearOverlay { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); pointer-events:none; display:none; z-index:10; text-align:center; }
  #clearOverlay .text { font-weight:900; color:#fff59d; text-shadow:0 6px 18px rgba(0,0,0,0.8); font-size:48px; letter-spacing:6px; }
  /* 小画面向けにフォントを少し縮小 */
  @media (max-width:360px) {
    #clearOverlay .text { font-size:36px; letter-spacing:4px; }
  }
</style>
</head>
<body>
  <div id="container">
    <div id="ui">
      <div class="info">武器: <span id="weaponText">ハンドガン</span>　仲間: <span id="allyText">0</span>　Kill: <span id="killText">0</span></div>
      <div><button id="restartBtn">Restart</button></div>
    </div>

    <div id="gameWrap">
      <canvas id="game" width="520" height="1100"></canvas>
      <div id="clearOverlay"><div class="text">CLEAR!!</div></div>
    </div>

    <div id="message"></div>
    <div class="hint">画面をタッチして指を置いた位置にキャラが移動します（下のレーンに張り付き）</div>
  </div>

<script>
/*
  変更点（今回の完全版）
  - canvas を画面幅・利用可能高さいっぱいに近づける（縦横をより活用）
  - 味方の列幅を動的に計算して、画面幅の2/3を占めないように調整
  - CLEAR は canvas 描画しない（DOM overlay のみ）
  - visualViewport が使える場合は優先して高さを取得（in-app browser 対応）
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const clearOverlay = document.getElementById('clearOverlay');

const killText = document.getElementById('killText');
const weaponText = document.getElementById('weaponText');
const allyText = document.getElementById('allyText');
const messageEl = document.getElementById('message');
const restartBtn = document.getElementById('restartBtn');

/* 論理ゲームサイズ（初期値。リサイズで上書き） */
let CSS_WIDTH = 520;
let CSS_HEIGHT = 1100;

const PLAYER_SPEED = 4;
const PLAYER_RADIUS = 16;
const BULLET_SPEED = 600;
let ENEMY_SPEED = 0.9;
const ITEM_SPEED = 0.55;
const ENEMY_RADIUS = 11;
const SURVIVE_TIME = 60;

let keys = {};
let lastTime = performance.now();
let elapsedTime = 0;
let spawnTimerEnemy = 0;
let spawnTimerItem = 0;
let enemySpawnInterval = 0.9;
let itemSpawnInterval = 2.5;
let shootCooldown = 0;

let player;
let bullets = [];
let enemyGroups = [];
let items = [];
let allies = [];
let killCount = 0;
let isGameOver = false;
let boss = null;

let particles = [];
let floatingTexts = [];

let weapon = { shotgun: 0, assault: 0, laser: 0, missile: 0 };

let touchX = null;
let touchActive = false;
let touchIndicator = null;

/* リサイズ：画面幅・利用可能高さをより広く使う */
function resizeCanvasToDisplaySize() {
  // 親幅（画面幅に近い）を基準に
  const containerRect = document.getElementById('container').getBoundingClientRect();
  const cssW = Math.max(300, Math.floor(containerRect.width)); // 最小幅を確保

  // visualViewport が使えるなら優先して利用（in-app ブラウザ対策）
  const viewportH = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight;

  // UI の高さを差し引く（#ui の高さを取得）
  const uiRect = document.getElementById('ui').getBoundingClientRect();
  const reserved = uiRect.height + 40 + (parseFloat(getComputedStyle(document.body).paddingBottom) || 0);

  // 画面に収まる高さを確保（上下の余白を少し残す）
  const availableH = Math.max(360, Math.floor(viewportH - reserved));

  // ここでは縦横比を固定せず、できるだけ幅と高さを活用する
  const cssH = Math.max(420, Math.floor(availableH)); // 最低高さを確保

  // 更新
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  CSS_WIDTH = cssW;
  CSS_HEIGHT = cssH;

  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(CSS_WIDTH * dpr);
  canvas.height = Math.floor(CSS_HEIGHT * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // overlay は CSS 中央にあるので JS 側で位置調整不要
}

/* 座標変換 */
function clientXToCanvasX(clientX) {
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (CSS_WIDTH / rect.width);
  return Math.max(PLAYER_RADIUS, Math.min(CSS_WIDTH - PLAYER_RADIUS, x));
}
function clientYToCanvasY(clientY) {
  const rect = canvas.getBoundingClientRect();
  const y = (clientY - rect.top) * (CSS_HEIGHT / rect.height);
  return Math.max(0, Math.min(CSS_HEIGHT, y));
}

/* 初期化 */
function resetGame() {
  player = { x: CSS_WIDTH/2, y: CSS_HEIGHT - 60, hp: 100, facing: -Math.PI/2 };
  bullets = [];
  enemyGroups = [];
  items = [];
  allies = [];
  boss = null;
  particles = [];
  floatingTexts = [];
  killCount = 0;
  elapsedTime = 0;
  spawnTimerEnemy = 0;
  spawnTimerItem = 0;
  shootCooldown = 0;
  isGameOver = false;
  weapon = { shotgun: 0, assault: 0, laser: 0, missile: 0 };
  killText.textContent = killCount;
  allyText.textContent = allies.length;
  weaponText.textContent = "ハンドガン";
  messageEl.textContent = "";
  touchX = null; touchActive = false; touchIndicator = null;
  clearOverlay.style.display = 'none';
}
restartBtn.addEventListener('click', () => {
  resetGame();
  resizeCanvasToDisplaySize();
  player.x = Math.max(PLAYER_RADIUS, Math.min(CSS_WIDTH - PLAYER_RADIUS, player.x));
  player.y = CSS_HEIGHT - 60;
});

/* キーボード（デスクトップ用） */
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

/* タッチ / ポインタ */
canvas.addEventListener('touchstart', (ev) => {
  ev.preventDefault();
  const t = ev.touches[0];
  touchX = clientXToCanvasX(t.clientX);
  touchActive = true;
  touchIndicator = { x: touchX, y: clientYToCanvasY(t.clientY) };
}, { passive: false });

canvas.addEventListener('touchmove', (ev) => {
  ev.preventDefault();
  const t = ev.touches[0];
  touchX = clientXToCanvasX(t.clientX);
  touchActive = true;
  touchIndicator = { x: touchX, y: clientYToCanvasY(t.clientY) };
}, { passive: false });

canvas.addEventListener('touchend', (ev) => {
  ev.preventDefault();
  touchActive = false;
  touchX = null;
  touchIndicator = null;
}, { passive: false });

canvas.addEventListener('pointerdown', (ev) => {
  ev.preventDefault();
  touchX = clientXToCanvasX(ev.clientX);
  touchActive = true;
  touchIndicator = { x: touchX, y: clientYToCanvasY(ev.clientY) };
});
canvas.addEventListener('pointermove', (ev) => {
  if (!touchActive) return;
  ev.preventDefault();
  touchX = clientXToCanvasX(ev.clientX);
  touchIndicator = { x: touchX, y: clientYToCanvasY(ev.clientY) };
});
canvas.addEventListener('pointerup', (ev) => {
  ev.preventDefault();
  touchActive = false;
  touchX = null;
  touchIndicator = null;
});
canvas.addEventListener('pointercancel', (ev) => {
  ev.preventDefault();
  touchActive = false;
  touchX = null;
  touchIndicator = null;
});

window.addEventListener('resize', () => {
  resizeCanvasToDisplaySize();
  if (player) {
    player.x = Math.max(PLAYER_RADIUS, Math.min(CSS_WIDTH - PLAYER_RADIUS, player.x));
    player.y = CSS_HEIGHT - 60;
  }
});

/* ====== ゲームロジック（弾は真上） ====== */
function spawnEnemyGroup() {
  const totalEnemies = enemyGroups.reduce((s,g)=>s+g.enemies.length,0);
  const TOTAL_ENEMY_CAP = 160;
  if (totalEnemies >= TOTAL_ENEMY_CAP) return;

  const progress = Math.min(elapsedTime / SURVIVE_TIME, 1);
  const growthDelay = 0.45;
  const p = progress <= growthDelay ? 0 : (progress - growthDelay) / (1 - growthDelay);

  const bandMin = 0.20, bandMax = 0.95;
  const bandWidth = CSS_WIDTH * (bandMin + (bandMax - bandMin) * Math.pow(progress, 1.2));
  const bandStart = Math.random() * Math.max(0, CSS_WIDTH - bandWidth);
  let centerX = bandStart + bandWidth / 2;

  const edgeMargin = Math.max(28, ENEMY_RADIUS * 2);
  centerX = Math.min(Math.max(centerX, edgeMargin), CSS_WIDTH - edgeMargin);

  const group = { x: centerX, y: -40, enemies: [] };

  const baseMin = 2, baseMax = 4;
  const raw = baseMin + Math.floor(Math.random() * (baseMax - baseMin + 1));
  const maxMultiplier = 4.5;
  const scale = 0.3 + Math.pow(p, 1.2) * (maxMultiplier - 0.3);
  const maxCountCap = 20;
  const count = Math.min(maxCountCap, Math.max(1, Math.floor(raw * scale)));

  const baseEnemyHPMin = 6, baseEnemyHPMax = 12;
  const hpScale = 1 + p * 1.0;

  const rMinStart = 6, rMaxStart = 10;
  const rMinEnd = 20, rMaxEnd = Math.min(CSS_WIDTH * 0.45, 160);
  const rMin = rMinStart + (rMinEnd - rMinStart) * progress;
  const rMax = rMaxStart + (rMaxEnd - rMaxStart) * progress;

  const localMargin = 10;

  for (let i=0;i<count;i++){
    const r = rMin + Math.random() * (rMax - rMin);
    const ang = Math.random() * Math.PI * 2;
    let ox = Math.cos(ang) * r;
    let oy = Math.sin(ang) * r;

    const minOx = edgeMargin - group.x + localMargin;
    const maxOx = (CSS_WIDTH - edgeMargin) - group.x - localMargin;
    ox = Math.min(Math.max(ox, minOx), maxOx);

    const baseHP = baseEnemyHPMin + Math.floor(Math.random() * (baseEnemyHPMax - baseEnemyHPMin + 1));
    const hp = Math.max(1, Math.floor(baseHP * hpScale));
    group.enemies.push({ ox, oy, jitterPhase: Math.random() * Math.PI * 2, hp });
  }

  let eliteChance = 0;
  if (p > 0) eliteChance = 0.02 + Math.pow(p, 1.2) * 0.08;
  const maxElitePerGroup = 2;
  if (Math.random() < eliteChance) {
    const extra = Math.min(maxElitePerGroup, 1 + Math.floor(p * 1));
    for (let k=0;k<extra;k++){
      const ox = (Math.random()-0.5) * Math.min(bandWidth, 300);
      const oy = (Math.random()-0.5) * Math.min(rMax, 160);
      const clampedOx = Math.min(Math.max(ox, edgeMargin - group.x + localMargin), (CSS_WIDTH - edgeMargin) - group.x - localMargin);
      const eliteBase = 200 + Math.random() * 120;
      const eliteHp = Math.floor(eliteBase * (1 + p * 0.6));
      group.enemies.push({ ox: clampedOx, oy, jitterPhase: Math.random() * Math.PI * 2, hp: eliteHp, isElite: true });
    }
  }

  let minOy = Infinity;
  for (const e of group.enemies) if (e.oy < minOy) minOy = e.oy;
  const spawnOffset = 18;
  group.y = -spawnOffset - minOy;

  group.x = Math.min(Math.max(group.x, edgeMargin), CSS_WIDTH - edgeMargin);

  enemyGroups.push(group);
}

function spawnBoss() {
  boss = {
    x: CSS_WIDTH/2,
    y: -180,
    hp: 32000 + Math.floor(Math.random()*10000),
    speed: 0.5,
    radius: Math.max(64, Math.floor(CSS_WIDTH * 0.12)),
    dead: false,
    deathTimer: 0
  };
}

function spawnItem() {
  if (boss && !boss.dead) return;

  const edgeMargin = 40;
  const x = Math.min(Math.max(Math.random() * CSS_WIDTH, edgeMargin), CSS_WIDTH - edgeMargin);
  const progress = Math.min(elapsedTime / SURVIVE_TIME, 1);
  const allyProb = 0.40;
  const baseItemSpeed = ITEM_SPEED;

  if (Math.random() < allyProb) {
    const value = Math.random() < 0.25 ? 2 : 1;
    items.push({ x, y: -20, type: "ally", value, speed: baseItemSpeed });
    return;
  }

  const growthDelay = 0.6;
  const p = progress <= growthDelay ? 0 : (progress - growthDelay) / (1 - growthDelay);
  const guardMin = 6, guardMid = 40, guardMax = 180;
  let guard;
  if (p <= 0) guard = guardMin + Math.floor(Math.random()*3);
  else if (p < 0.6) {
    const t = p / 0.6;
    guard = Math.floor(guardMin + Math.pow(t, 1.8) * (guardMid - guardMin));
  } else {
    const t = (p - 0.6) / 0.4;
    guard = Math.floor(guardMid + Math.pow(t, 1.4) * (guardMax - guardMid));
  }

  items.push({ x, y: -20, type: "weapon", guard, speed: baseItemSpeed });
}

function upgradeWeapon() {
  const roll = Math.random();
  if (roll < 0.25) { weapon.shotgun++; weaponText.textContent = "ショットガン Lv" + weapon.shotgun; }
  else if (roll < 0.5) { weapon.assault++; weaponText.textContent = "アサルト Lv" + weapon.assault; }
  else if (roll < 0.75) { weapon.laser++; weaponText.textContent = "レーザー Lv" + weapon.laser; }
  else { weapon.missile++; weaponText.textContent = "ミサイル Lv" + weapon.missile; }
}

function computeGunTip(x,y,facing,ownerRadius){
  const offset = ownerRadius + 8;
  return { tx: x + Math.cos(facing)*offset, ty: y + Math.sin(facing)*offset };
}
function shootPlayer(x,y){
  const angle = -Math.PI/2;
  const tip = computeGunTip(x, y-6, angle, PLAYER_RADIUS);
  const speed = BULLET_SPEED;
  const piercing = weapon.laser > 0;
  const count = 1 + weapon.shotgun * 2;
  for (let i=0;i<count;i++){
    bullets.push({
      x: tip.tx, y: tip.ty,
      angle: angle, speed: speed,
      piercing, isAlly:false,
      createdAt: performance.now(), life: 4200
    });
  }
}
function shootAlly(a){
  const angle = -Math.PI/2;
  const tip = computeGunTip(a.x, a.y-4, angle, 10);
  bullets.push({
    x: tip.tx, y: tip.ty,
    angle: angle, speed: BULLET_SPEED * 0.7,
    piercing:false, isAlly:true,
    createdAt: performance.now(), life: 3200
  });
}

/* ====== 仲間更新（列幅を動的に計算して横幅を占有しすぎないように） ====== */
function updateAllies(){
  // colWidth を画面幅に応じて決定（小さすぎず大きすぎない）
  const colWidth = Math.max(28, Math.floor(CSS_WIDTH * 0.06));
  // maxPerRow は画面幅に応じて決定（最大8列）
  const maxPerRow = Math.min(8, Math.max(3, Math.floor(CSS_WIDTH / colWidth)));
  allies.forEach((a,i)=>{
    const col = i % maxPerRow;
    const row = Math.floor(i / maxPerRow);
    const totalCols = Math.min(allies.length - row * maxPerRow, maxPerRow);
    const startX = player.x - (totalCols - 1) * colWidth / 2;
    const targetX = startX + col * colWidth;
    const targetY = player.y + 40 + row * 30;
    a.x += (targetX - a.x) * 0.22;
    a.y += (targetY - a.y) * 0.22;
    if (Math.random() < 0.02) shootAlly(a);
  });
}

/* ====== 爆発 / レベルアップ演出 ====== */
function spawnExplosion(x,y,color="#ffcc66",count=40){
  for (let i=0;i<count;i++){
    const ang = Math.random()*Math.PI*2;
    const speed = 1 + Math.random()*4;
    particles.push({ x,y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, life:0, ttl:0.8 + Math.random()*0.6, color });
  }
}
function spawnLevelUpEffect(x,y,text="Level Up!"){
  spawnExplosion(x,y,"#ffd166",14);
  floatingTexts.push({ x, y, text, life:0, ttl:1.2, vy:-30 });
}

function checkEnemyReachedBottom(){
  const bottomLine = CSS_HEIGHT - 120;
  for (const g of enemyGroups){
    for (const e of g.enemies){
      const ey = g.y + e.oy;
      if (ey > bottomLine) return true;
    }
  }
  return false;
}

/* ====== 更新 ====== */
function update(dt){
  if (isGameOver) return;
  dt = Math.min(dt, 0.05);
  elapsedTime += dt;

  const progress = Math.min(elapsedTime / SURVIVE_TIME, 1);
  const growthDelay = 0.5;
  const p = progress <= growthDelay ? 0 : (progress - growthDelay) / (1 - growthDelay);

  enemySpawnInterval = p === 0 ? 1.2 : Math.max(0.35, 1.2 - Math.pow(p, 1.0) * 1.0);
  const enemySpeed = ENEMY_SPEED + p * 0.35;

  if (!boss && elapsedTime >= SURVIVE_TIME) spawnBoss();

  if (boss && boss.dead) {
    boss.deathTimer += dt;
    if (boss.deathTimer < 0.6 && Math.random() < 0.2) {
      spawnExplosion(boss.x + (Math.random()-0.5)*boss.radius, boss.y + (Math.random()-0.5)*boss.radius, "#ff6666", 6);
    }
    if (boss.deathTimer >= 1.2) {
      isGameOver = true;
      messageEl.textContent = "ボス撃破！クリア！";
      clearOverlay.style.display = 'block';
    }
  }

  if (!boss) {
    spawnTimerEnemy += dt;
    if (spawnTimerEnemy >= enemySpawnInterval) {
      spawnTimerEnemy = 0;
      spawnEnemyGroup();
    }
  }

  spawnTimerItem += dt;
  if (spawnTimerItem >= itemSpawnInterval) {
    spawnTimerItem = 0;
    spawnItem();
  }

  // プレイヤー移動（タッチ追従）
  if (touchX !== null) {
    const followLerp = 0.32; // 少し追従を速めにして操作感を良くする
    player.x += (touchX - player.x) * followLerp;
    player.facing = -Math.PI/2;
  } else {
    if (keys['a'] || keys['arrowleft']) { player.x -= PLAYER_SPEED; player.facing = -Math.PI/2 - 0.25; }
    if (keys['d'] || keys['arrowright']) { player.x += PLAYER_SPEED; player.facing = -Math.PI/2 + 0.25; }
    if (!keys['a'] && !keys['d']) player.facing = -Math.PI/2;
  }
  player.x = Math.max(PLAYER_RADIUS, Math.min(CSS_WIDTH - PLAYER_RADIUS, player.x));
  player.y = CSS_HEIGHT - 60;

  shootCooldown -= dt;
  let interval = 0.45 - weapon.assault * 0.03;
  if (interval < 0.12) interval = 0.12;
  if (shootCooldown <= 0) {
    shootPlayer(player.x, player.y);
    shootCooldown = interval;
  }

  updateAllies();

  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += Math.cos(b.angle) * b.speed * dt;
    b.y += Math.sin(b.angle) * b.speed * dt;
    if (b.createdAt && b.life && (performance.now() - b.createdAt > b.life)) { bullets.splice(i,1); continue; }
    if (b.y < -80 || b.y > CSS_HEIGHT + 80 || b.x < -80 || b.x > CSS_WIDTH + 80) { bullets.splice(i,1); continue; }
  }

  for (let gi = enemyGroups.length - 1; gi >= 0; gi--) {
    const g = enemyGroups[gi];
    g.y += enemySpeed;
    for (let ei = g.enemies.length - 1; ei >= 0; ei--) {
      const e = g.enemies[ei];
      const jitter = Math.sin(elapsedTime * 2 + e.jitterPhase) * 2;
      const ex = g.x + e.ox + jitter;
      const ey = g.y + e.oy;
      if (Math.hypot(player.x - ex, player.y - ey) < PLAYER_RADIUS + ENEMY_RADIUS) {
        player.hp -= 20 * dt;
        if (player.hp <= 0) { isGameOver = true; messageEl.textContent = "ゲームオーバー"; }
      }
    }
    if (g.y > CSS_HEIGHT + 120 || g.enemies.length === 0) enemyGroups.splice(gi,1);
  }

  if (checkEnemyReachedBottom()) {
    isGameOver = true;
    messageEl.textContent = "敵が到達しました…ゲームオーバー";
    return;
  }

  if (boss && !boss.dead) {
    boss.y += boss.speed;
    if (Math.hypot(player.x - boss.x, player.y - boss.y) < PLAYER_RADIUS + boss.radius) {
      player.hp -= 30 * dt;
      if (player.hp <= 0) { isGameOver = true; messageEl.textContent = "ゲームオーバー"; }
    }
  }

  for (let i = items.length - 1; i >= 0; i--) {
    const it = items[i];
    const s = (typeof it.speed === 'number') ? it.speed : ITEM_SPEED;
    it.y += s;
    if (it.type === 'ally') {
      if (Math.abs(player.x - it.x) < 40 && Math.abs(player.y - it.y) < 20) {
        for (let n=0;n<it.value;n++){
          allies.push({ x: player.x + (Math.random()-0.5)*10, y: player.y + 40 + Math.random()*6 });
        }
        allyText.textContent = allies.length;
        items.splice(i,1);
        continue;
      }
    }
    if (it.y > CSS_HEIGHT + 80) items.splice(i,1);
  }

  for (let bi = bullets.length - 1; bi >= 0; bi--) {
    const b = bullets[bi];
    let hit = false;
    for (let gi = 0; gi < enemyGroups.length && !hit; gi++) {
      const g = enemyGroups[gi];
      for (let ei = g.enemies.length - 1; ei >= 0; ei--) {
        const e = g.enemies[ei];
        const jitter = Math.sin(elapsedTime * 2 + e.jitterPhase) * 2;
        const ex = g.x + e.ox + jitter;
        const ey = g.y + e.oy;
        const radius = e.isElite ? ENEMY_RADIUS * 1.6 : ENEMY_RADIUS;
        const hitThreshold = radius + 6;
        if (Math.hypot(ex - b.x, ey - b.y) < hitThreshold) {
          e.hp -= 10;
          if (!b.piercing) bullets.splice(bi,1);
          if (e.hp <= 0) { g.enemies.splice(ei,1); killCount++; killText.textContent = killCount; }
          hit = true;
          break;
        }
      }
    }
    if (hit) continue;
    if (boss && !boss.dead && Math.hypot(boss.x - b.x, boss.y - b.y) < boss.radius + 6) {
      boss.hp -= 10;
      if (!b.piercing) bullets.splice(bi,1);
      if (boss.hp <= 0) { boss.dead = true; spawnExplosion(boss.x, boss.y, "#ffcc66", 80); }
    }
  }

  for (let bi = bullets.length - 1; bi >= 0; bi--) {
    const b = bullets[bi];
    for (let ii = items.length - 1; ii >= 0; ii--) {
      const it = items[ii];
      if (it.type !== 'weapon') continue;
      if (b.x > it.x - 40 && b.x < it.x + 40 && Math.abs(b.y - it.y) < 15) {
        it.guard--;
        bullets.splice(bi,1);
        if (it.guard <= 0) {
          spawnLevelUpEffect(it.x, it.y, (!boss || boss.dead) ? "Level Up!" : "Shattered");
          if (!boss || boss.dead) upgradeWeapon();
          items.splice(ii,1);
        }
        break;
      }
    }
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.06;
    p.life += dt;
    if (p.life >= p.ttl) particles.splice(i,1);
  }

  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.life += dt;
    t.y += t.vy * dt;
    if (t.life >= t.ttl) floatingTexts.splice(i,1);
  }

  allyText.textContent = allies.length;
  killText.textContent = killCount;
}

/* ====== 描画（CLEAR は DOM overlay のみ） ====== */
function drawHuman(x,y,scale=1,color="#4caf50",gunColor="#333"){
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.arc(x, y - 18*scale, 8*scale, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = color; ctx.fillRect(x - 6*scale, y - 12*scale, 12*scale, 18*scale);
  ctx.fillRect(x - 14*scale, y - 10*scale, 8*scale, 4*scale);
  ctx.fillRect(x + 6*scale, y - 10*scale, 8*scale, 4*scale);
  ctx.fillRect(x - 8*scale, y + 6*scale, 4*scale, 10*scale);
  ctx.fillRect(x + 4*scale, y + 6*scale, 4*scale, 10*scale);
  ctx.fillStyle = gunColor; ctx.fillRect(x + 8*scale, y - 8*scale, 18*scale, 4*scale);
  ctx.fillRect(x + 6*scale, y - 10*scale, 6*scale, 6*scale);
}

function draw(){
  ctx.clearRect(0,0,CSS_WIDTH,CSS_HEIGHT);
  ctx.fillStyle = "#151515"; ctx.fillRect(0,0,CSS_WIDTH,CSS_HEIGHT);

  drawHuman(player.x, player.y, 1.0, "#4caf50", "#222");

  allies.forEach(a => drawHuman(a.x, a.y, 0.8, "#66bb6a", "#222"));

  bullets.forEach(b => {
    ctx.fillStyle = b.isAlly ? "#ffd" : "#ffeb3b";
    ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
  });

  enemyGroups.forEach(g => {
    g.enemies.forEach(e => {
      const jitter = Math.sin(elapsedTime * 2 + e.jitterPhase) * 3;
      const ex = g.x + e.ox + jitter;
      const ey = g.y + e.oy;
      if (e.isElite) {
        const pulse = 1 + 0.06 * Math.sin(elapsedTime * 6 + e.jitterPhase);
        const eliteRadius = ENEMY_RADIUS * 1.6 * pulse;
        ctx.beginPath(); ctx.fillStyle = "#ffd166"; ctx.arc(ex, ey, eliteRadius, 0, Math.PI*2); ctx.fill();
        ctx.lineWidth = 2; ctx.strokeStyle = "#ff8c42"; ctx.stroke();
        ctx.globalAlpha = 0.12; ctx.beginPath(); ctx.fillStyle = "#ffd166"; ctx.arc(ex, ey, eliteRadius + 6, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
      } else {
        ctx.beginPath(); ctx.fillStyle = "#e53935"; ctx.arc(ex, ey, ENEMY_RADIUS, 0, Math.PI*2); ctx.fill();
      }
    });
  });

  if (boss && !boss.dead) {
    ctx.fillStyle = "#ff4444"; ctx.beginPath(); ctx.arc(boss.x, boss.y, boss.radius, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "#fff"; ctx.font = "18px sans-serif"; ctx.fillText("Boss HP: " + boss.hp, boss.x - 60, boss.y - boss.radius - 10);
  }

  particles.forEach(p => {
    ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, 1 - p.life / p.ttl);
    ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
  });

  floatingTexts.forEach(t => {
    const alpha = Math.max(0, 1 - t.life / t.ttl);
    ctx.globalAlpha = alpha; ctx.fillStyle = "#fff59d"; ctx.font = "18px sans-serif";
    ctx.fillText(t.text, t.x - (t.text.length * 5), t.y);
    ctx.globalAlpha = 1;
  });

  items.forEach(it => {
    if (it.type === 'weapon') {
      ctx.fillStyle = "#29b6f6"; ctx.fillRect(it.x - 40, it.y - 10, 80, 20);
      ctx.fillStyle = "#fff"; ctx.font = "14px sans-serif"; ctx.fillText("G:" + it.guard, it.x - 15, it.y + 5);
    } else {
      ctx.fillStyle = "#66ff66"; ctx.fillRect(it.x - 40, it.y - 10, 80, 20);
      ctx.fillStyle = "#000"; ctx.font = "16px sans-serif"; ctx.fillText("+" + it.value, it.x - 8, it.y + 6);
    }
  });

  if (touchIndicator) {
    ctx.globalAlpha = 0.28;
    ctx.fillStyle = "#88ccff";
    ctx.beginPath();
    ctx.arc(touchIndicator.x, touchIndicator.y, 28, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // CLEAR は canvas 上では描かない（DOM overlay を使う）

  ctx.fillStyle = "#fff";
  ctx.font = Math.max(12, Math.floor(CSS_WIDTH * 0.03)) + "px sans-serif";
  ctx.fillText("HP: " + Math.max(0, Math.floor(player.hp)), 10, 18);
}

/* ====== メインループ ====== */
function gameLoop(now){
  const t = now || performance.now();
  const dt = Math.min((t - lastTime) / 1000, 0.05);
  lastTime = t;

  update(dt);
  draw();

  requestAnimationFrame(gameLoop);
}

/* 起動 */
function start() {
  resizeCanvasToDisplaySize();
  resetGame();
  requestAnimationFrame((t) => { lastTime = t; gameLoop(t); });
}
start();

</script>
</body>
</html>