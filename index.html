<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Vertical Lane Survival - スマホ対応版（タッチ操作）</title>
<style>
  html,body { height:100%; margin:0; background:#0b0b0b; color:#fff; font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; -webkit-tap-highlight-color: transparent; }
  #container { width:100%; max-width:480px; margin:12px auto; }
  #ui { display:flex; gap:8px; align-items:center; justify-content:space-between; margin-bottom:8px; }
  #game { display:block; width:100%; background:#151515; border:4px solid #333; box-sizing:border-box; }
  button { padding:6px 10px; background:#1f6feb; color:#fff; border:0; border-radius:6px; cursor:pointer; }
  .info { font-size:14px; color:#ddd; }
  #message { text-align:center; margin-top:8px; color:#ffd; min-height:20px; }
  /* タッチ操作の説明（小さく） */
  .hint { font-size:12px; color:#bbb; margin-top:6px; text-align:center; }
</style>
</head>
<body>
  <div id="container">
    <div id="ui">
      <div class="info">武器: <span id="weaponText">ハンドガン</span>　仲間: <span id="allyText">0</span>　Kill: <span id="killText">0</span></div>
      <div><button id="restartBtn">Restart</button></div>
    </div>
    <canvas id="game" width="450" height="800"></canvas>
    <div id="message"></div>
    <div class="hint">画面をタッチして指を置いた位置にキャラが移動します（下のレーンに張り付き）</div>
  </div>

<script>
/* ====== スマホ対応版（タッチで指のXに追従） ====== */

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const killText = document.getElementById('killText');
const weaponText = document.getElementById('weaponText');
const allyText = document.getElementById('allyText');
const messageEl = document.getElementById('message');
const restartBtn = document.getElementById('restartBtn');

const WIDTH = canvas.width, HEIGHT = canvas.height;

const PLAYER_SPEED = 4;
const PLAYER_RADIUS = 16;
const BULLET_SPEED = 600; // px/s
let ENEMY_SPEED = 0.9;
const ITEM_SPEED = 0.55;
const ENEMY_RADIUS = 11;
const SURVIVE_TIME = 60;

let keys = {};
let lastTime = performance.now();
let elapsedTime = 0;
let spawnTimerEnemy = 0;
let spawnTimerItem = 0;
let enemySpawnInterval = 0.9;
let itemSpawnInterval = 2.5;
let shootCooldown = 0;

let player;
let bullets = [];
let enemyGroups = [];
let items = [];
let allies = [];
let killCount = 0;
let isGameOver = false;
let boss = null;

let particles = [];
let floatingTexts = [];

let weapon = { shotgun: 0, assault: 0, laser: 0, missile: 0 };

/* ====== タッチ制御変数 ====== */
let touchX = null;           // キャンバス座標でのターゲットX（null = タッチなし）
let touchActive = false;     // タッチ中フラグ
let touchIndicator = null;   // {x,y} を描画するための位置（画面上の指位置）

/* ====== 初期化 ====== */
function resetGame() {
  player = { x: WIDTH/2, y: HEIGHT - 40, hp: 100, facing: -Math.PI/2 };
  bullets = [];
  enemyGroups = [];
  items = [];
  allies = [];
  boss = null;
  particles = [];
  floatingTexts = [];
  killCount = 0;
  elapsedTime = 0;
  spawnTimerEnemy = 0;
  spawnTimerItem = 0;
  shootCooldown = 0;
  isGameOver = false;
  weapon = { shotgun: 0, assault: 0, laser: 0, missile: 0 };
  killText.textContent = killCount;
  allyText.textContent = allies.length;
  weaponText.textContent = "ハンドガン";
  messageEl.textContent = "";
  touchX = null;
  touchActive = false;
  touchIndicator = null;
}
restartBtn.addEventListener('click', resetGame);

/* キーボード（デスクトップ用） */
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

/* ====== タッチ / ポインターイベント ====== */
/* ユーザーがタッチした位置をキャンバス座標に変換して touchX に保存する */
function clientXToCanvasX(clientX) {
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (canvas.width / rect.width);
  return Math.max(PLAYER_RADIUS, Math.min(canvas.width - PLAYER_RADIUS, x));
}
function clientYToCanvasY(clientY) {
  const rect = canvas.getBoundingClientRect();
  const y = (clientY - rect.top) * (canvas.height / rect.height);
  return Math.max(0, Math.min(canvas.height, y));
}

/* タッチイベント */
canvas.addEventListener('touchstart', (ev) => {
  ev.preventDefault();
  const t = ev.touches[0];
  touchX = clientXToCanvasX(t.clientX);
  touchActive = true;
  touchIndicator = { x: touchX, y: clientYToCanvasY(t.clientY) };
}, { passive: false });

canvas.addEventListener('touchmove', (ev) => {
  ev.preventDefault();
  const t = ev.touches[0];
  touchX = clientXToCanvasX(t.clientX);
  touchActive = true;
  touchIndicator = { x: touchX, y: clientYToCanvasY(t.clientY) };
}, { passive: false });

canvas.addEventListener('touchend', (ev) => {
  ev.preventDefault();
  touchActive = false;
  touchX = null;
  touchIndicator = null;
}, { passive: false });

/* ポインター（マウス）対応：デスクトップでも同じ操作感 */
canvas.addEventListener('pointerdown', (ev) => {
  ev.preventDefault();
  touchX = clientXToCanvasX(ev.clientX);
  touchActive = true;
  touchIndicator = { x: touchX, y: clientYToCanvasY(ev.clientY) };
});
canvas.addEventListener('pointermove', (ev) => {
  if (!touchActive) return;
  ev.preventDefault();
  touchX = clientXToCanvasX(ev.clientX);
  touchIndicator = { x: touchX, y: clientYToCanvasY(ev.clientY) };
});
canvas.addEventListener('pointerup', (ev) => {
  ev.preventDefault();
  touchActive = false;
  touchX = null;
  touchIndicator = null;
});
canvas.addEventListener('pointercancel', (ev) => {
  ev.preventDefault();
  touchActive = false;
  touchX = null;
  touchIndicator = null;
});

/* ====== 既存ゲームロジック（敵生成・弾・アイテム等） ====== */
/* 敵群れ生成（端寄せ防止・上端補正） */
function spawnEnemyGroup() {
  const totalEnemies = enemyGroups.reduce((s,g)=>s+g.enemies.length,0);
  const TOTAL_ENEMY_CAP = 120;
  if (totalEnemies >= TOTAL_ENEMY_CAP) return;

  const progress = Math.min(elapsedTime / SURVIVE_TIME, 1);
  const growthDelay = 0.45;
  const p = progress <= growthDelay ? 0 : (progress - growthDelay) / (1 - growthDelay);

  const bandMin = 0.30, bandMax = 0.90;
  const bandWidth = WIDTH * (bandMin + (bandMax - bandMin) * Math.pow(progress, 1.2));
  const bandStart = Math.random() * Math.max(0, WIDTH - bandWidth);
  let centerX = bandStart + bandWidth / 2;

  const edgeMargin = Math.max(40, ENEMY_RADIUS * 2);
  centerX = Math.min(Math.max(centerX, edgeMargin), WIDTH - edgeMargin);

  const group = { x: centerX, y: -40, enemies: [] };

  const baseMin = 2, baseMax = 4;
  const raw = baseMin + Math.floor(Math.random() * (baseMax - baseMin + 1));
  const maxMultiplier = 4.5;
  const scale = 0.3 + Math.pow(p, 1.2) * (maxMultiplier - 0.3);
  const maxCountCap = 14;
  const count = Math.min(maxCountCap, Math.max(1, Math.floor(raw * scale)));

  const baseEnemyHPMin = 6, baseEnemyHPMax = 12;
  const hpScale = 1 + p * 1.0;

  const rMinStart = 6, rMaxStart = 10;
  const rMinEnd = 20, rMaxEnd = Math.min(WIDTH * 0.4, 90);
  const rMin = rMinStart + (rMinEnd - rMinStart) * progress;
  const rMax = rMaxStart + (rMaxEnd - rMaxStart) * progress;

  const localMargin = 12;

  for (let i=0;i<count;i++){
    const r = rMin + Math.random() * (rMax - rMin);
    const ang = Math.random() * Math.PI * 2;
    let ox = Math.cos(ang) * r;
    let oy = Math.sin(ang) * r;

    const minOx = edgeMargin - group.x + localMargin;
    const maxOx = (WIDTH - edgeMargin) - group.x - localMargin;
    ox = Math.min(Math.max(ox, minOx), maxOx);

    const baseHP = baseEnemyHPMin + Math.floor(Math.random() * (baseEnemyHPMax - baseEnemyHPMin + 1));
    const hp = Math.max(1, Math.floor(baseHP * hpScale));
    group.enemies.push({ ox, oy, jitterPhase: Math.random() * Math.PI * 2, hp });
  }

  let eliteChance = 0;
  if (p > 0) eliteChance = 0.02 + Math.pow(p, 1.2) * 0.08;
  const maxElitePerGroup = 1;
  if (Math.random() < eliteChance) {
    const extra = Math.min(maxElitePerGroup, 1 + Math.floor(p * 1));
    for (let k=0;k<extra;k++){
      const ox = (Math.random()-0.5) * Math.min(bandWidth, 200);
      const oy = (Math.random()-0.5) * Math.min(rMax, 120);
      const clampedOx = Math.min(Math.max(ox, edgeMargin - group.x + localMargin), (WIDTH - edgeMargin) - group.x - localMargin);
      const eliteBase = 160 + Math.random() * 80;
      const eliteHp = Math.floor(eliteBase * (1 + p * 0.6));
      group.enemies.push({ ox: clampedOx, oy, jitterPhase: Math.random() * Math.PI * 2, hp: eliteHp, isElite: true });
    }
  }

  let minOy = Infinity;
  for (const e of group.enemies) if (e.oy < minOy) minOy = e.oy;
  const spawnOffset = 18;
  group.y = -spawnOffset - minOy;

  group.x = Math.min(Math.max(group.x, edgeMargin), WIDTH - edgeMargin);

  enemyGroups.push(group);
}

/* ボス生成 */
function spawnBoss() {
  boss = {
    x: WIDTH/2,
    y: -120,
    hp: 22000 + Math.floor(Math.random()*6000),
    speed: 0.5,
    radius: 56,
    dead: false,
    deathTimer: 0
  };
}

/* アイテム生成 */
function spawnItem() {
  if (boss && !boss.dead) return;

  const edgeMargin = 40;
  const x = Math.min(Math.max(Math.random() * WIDTH, edgeMargin), WIDTH - edgeMargin);
  const progress = Math.min(elapsedTime / SURVIVE_TIME, 1);
  const allyProb = 0.40;
  const baseItemSpeed = ITEM_SPEED;

  if (Math.random() < allyProb) {
    const value = Math.random() < 0.25 ? 2 : 1;
    items.push({ x, y: -20, type: "ally", value, speed: baseItemSpeed });
    return;
  }

  const growthDelay = 0.6;
  const p = progress <= growthDelay ? 0 : (progress - growthDelay) / (1 - growthDelay);
  const guardMin = 6, guardMid = 40, guardMax = 180;
  let guard;
  if (p <= 0) guard = guardMin + Math.floor(Math.random()*3);
  else if (p < 0.6) {
    const t = p / 0.6;
    guard = Math.floor(guardMin + Math.pow(t, 1.8) * (guardMid - guardMin));
  } else {
    const t = (p - 0.6) / 0.4;
    guard = Math.floor(guardMid + Math.pow(t, 1.4) * (guardMax - guardMid));
  }

  items.push({ x, y: -20, type: "weapon", guard, speed: baseItemSpeed });
}

/* 武器強化 */
function upgradeWeapon() {
  const roll = Math.random();
  if (roll < 0.25) { weapon.shotgun++; weaponText.textContent = "ショットガン Lv" + weapon.shotgun; }
  else if (roll < 0.5) { weapon.assault++; weaponText.textContent = "アサルト Lv" + weapon.assault; }
  else if (roll < 0.75) { weapon.laser++; weaponText.textContent = "レーザー Lv" + weapon.laser; }
  else { weapon.missile++; weaponText.textContent = "ミサイル Lv" + weapon.missile; }
}

/* 発射（常に真上） */
function computeGunTip(x,y,facing,ownerRadius){
  const offset = ownerRadius + 8;
  return { tx: x + Math.cos(facing)*offset, ty: y + Math.sin(facing)*offset };
}
function shootPlayer(x,y){
  const angle = -Math.PI/2; // 真上
  const tip = computeGunTip(x, y-6, angle, PLAYER_RADIUS);
  const speed = BULLET_SPEED;
  const piercing = weapon.laser > 0;
  const count = 1 + weapon.shotgun * 2;
  for (let i=0;i<count;i++){
    bullets.push({
      x: tip.tx, y: tip.ty,
      angle: angle, speed: speed,
      piercing, isAlly:false,
      createdAt: performance.now(), life: 4200
    });
  }
}
function shootAlly(a){
  const angle = -Math.PI/2;
  const tip = computeGunTip(a.x, a.y-4, angle, 10);
  bullets.push({
    x: tip.tx, y: tip.ty,
    angle: angle, speed: BULLET_SPEED * 0.7,
    piercing:false, isAlly:true,
    createdAt: performance.now(), life: 3200
  });
}

/* 仲間更新 */
function updateAllies(){
  const colWidth = 36;
  const maxPerRow = 6;
  allies.forEach((a,i)=>{
    const col = i % maxPerRow;
    const row = Math.floor(i / maxPerRow);
    const totalCols = Math.min(allies.length - row * maxPerRow, maxPerRow);
    const startX = player.x - (totalCols - 1) * colWidth / 2;
    const targetX = startX + col * colWidth;
    const targetY = player.y + 40 + row * 30;
    a.x += (targetX - a.x) * 0.22;
    a.y += (targetY - a.y) * 0.22;
    if (Math.random() < 0.02) shootAlly(a);
  });
}

/* 爆発パーティクル */
function spawnExplosion(x,y,color="#ffcc66",count=40){
  for (let i=0;i<count;i++){
    const ang = Math.random()*Math.PI*2;
    const speed = 1 + Math.random()*4;
    particles.push({ x,y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, life:0, ttl:0.8 + Math.random()*0.6, color });
  }
}

/* レベルアップ演出 */
function spawnLevelUpEffect(x,y,text="Level Up!"){
  spawnExplosion(x,y,"#ffd166",14);
  floatingTexts.push({ x, y, text, life:0, ttl:1.2, vy:-30 });
}

/* 敵が下ラインに到達したら敗北判定 */
function checkEnemyReachedBottom(){
  const bottomLine = HEIGHT - 90;
  for (const g of enemyGroups){
    for (const e of g.enemies){
      const ey = g.y + e.oy;
      if (ey > bottomLine) return true;
    }
  }
  return false;
}

/* ====== 更新 ====== */
function update(dt){
  if (isGameOver) return;

  dt = Math.min(dt, 0.05);
  elapsedTime += dt;

  const progress = Math.min(elapsedTime / SURVIVE_TIME, 1);
  const growthDelay = 0.5;
  const p = progress <= growthDelay ? 0 : (progress - growthDelay) / (1 - growthDelay);

  enemySpawnInterval = p === 0 ? 1.2 : Math.max(0.35, 1.2 - Math.pow(p, 1.0) * 1.0);
  const enemySpeed = ENEMY_SPEED + p * 0.35;

  if (!boss && elapsedTime >= SURVIVE_TIME) spawnBoss();

  if (boss && boss.dead) {
    boss.deathTimer += dt;
    if (boss.deathTimer < 0.6 && Math.random() < 0.2) {
      spawnExplosion(boss.x + (Math.random()-0.5)*boss.radius, boss.y + (Math.random()-0.5)*boss.radius, "#ff6666", 6);
    }
    if (boss.deathTimer >= 1.2) {
      isGameOver = true;
      messageEl.textContent = "ボス撃破！クリア！";
    }
  }

  if (!boss) {
    spawnTimerEnemy += dt;
    if (spawnTimerEnemy >= enemySpawnInterval) {
      spawnTimerEnemy = 0;
      spawnEnemyGroup();
    }
  }

  spawnTimerItem += dt;
  if (spawnTimerItem >= itemSpawnInterval) {
    spawnTimerItem = 0;
    spawnItem();
  }

  // プレイヤー移動：タッチがあれば touchX に滑らかに追従（下レーンに張り付き）
  if (touchX !== null) {
    // 追従速度（0..1）を調整すると追従の速さが変わる
    const followLerp = 0.28; // 小さくするとゆっくり、大きくすると瞬間移動に近い
    player.x += (touchX - player.x) * followLerp;
    // プレイヤーの向きは固定（見た目）
    player.facing = -Math.PI/2;
  } else {
    // キーボード操作（デスクトップ）
    if (keys['a'] || keys['arrowleft']) { player.x -= PLAYER_SPEED; player.facing = -Math.PI/2 - 0.25; }
    if (keys['d'] || keys['arrowright']) { player.x += PLAYER_SPEED; player.facing = -Math.PI/2 + 0.25; }
    if (!keys['a'] && !keys['d']) player.facing = -Math.PI/2;
  }
  // clamp X
  player.x = Math.max(PLAYER_RADIUS, Math.min(WIDTH - PLAYER_RADIUS, player.x));
  // ensure player stays on bottom lane
  player.y = HEIGHT - 40;

  // auto shooting
  shootCooldown -= dt;
  let interval = 0.45 - weapon.assault * 0.03;
  if (interval < 0.12) interval = 0.12;
  if (shootCooldown <= 0) {
    shootPlayer(player.x, player.y);
    shootCooldown = interval;
  }

  updateAllies();

  // 弾更新（角度/速度固定で直進）
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += Math.cos(b.angle) * b.speed * dt;
    b.y += Math.sin(b.angle) * b.speed * dt;
    if (b.createdAt && b.life && (performance.now() - b.createdAt > b.life)) { bullets.splice(i,1); continue; }
    if (b.y < -80 || b.y > HEIGHT + 80 || b.x < -80 || b.x > WIDTH + 80) { bullets.splice(i,1); continue; }
  }

  // 敵更新
  for (let gi = enemyGroups.length - 1; gi >= 0; gi--) {
    const g = enemyGroups[gi];
    g.y += enemySpeed;
    for (let ei = g.enemies.length - 1; ei >= 0; ei--) {
      const e = g.enemies[ei];
      const jitter = Math.sin(elapsedTime * 2 + e.jitterPhase) * 2;
      const ex = g.x + e.ox + jitter;
      const ey = g.y + e.oy;
      if (Math.hypot(player.x - ex, player.y - ey) < PLAYER_RADIUS + ENEMY_RADIUS) {
        player.hp -= 20 * dt;
        if (player.hp <= 0) { isGameOver = true; messageEl.textContent = "ゲームオーバー"; }
      }
    }
    if (g.y > HEIGHT + 120 || g.enemies.length === 0) enemyGroups.splice(gi,1);
  }

  if (checkEnemyReachedBottom()) {
    isGameOver = true;
    messageEl.textContent = "敵が到達しました…ゲームオーバー";
    return;
  }

  if (boss && !boss.dead) {
    boss.y += boss.speed;
    if (Math.hypot(player.x - boss.x, player.y - boss.y) < PLAYER_RADIUS + boss.radius) {
      player.hp -= 30 * dt;
      if (player.hp <= 0) { isGameOver = true; messageEl.textContent = "ゲームオーバー"; }
    }
  }

  // items update
  for (let i = items.length - 1; i >= 0; i--) {
    const it = items[i];
    const s = (typeof it.speed === 'number') ? it.speed : ITEM_SPEED;
    it.y += s;
    if (it.type === 'ally') {
      if (Math.abs(player.x - it.x) < 40 && Math.abs(player.y - it.y) < 20) {
        for (let n=0;n<it.value;n++){
          allies.push({ x: player.x + (Math.random()-0.5)*10, y: player.y + 40 + Math.random()*6 });
        }
        allyText.textContent = allies.length;
        items.splice(i,1);
        continue;
      }
    }
    if (it.y > HEIGHT + 80) items.splice(i,1);
  }

  // 弾と敵の当たり判定（群れ & ボス）
  for (let bi = bullets.length - 1; bi >= 0; bi--) {
    const b = bullets[bi];
    let hit = false;
    for (let gi = 0; gi < enemyGroups.length && !hit; gi++) {
      const g = enemyGroups[gi];
      for (let ei = g.enemies.length - 1; ei >= 0; ei--) {
        const e = g.enemies[ei];
        const jitter = Math.sin(elapsedTime * 2 + e.jitterPhase) * 2;
        const ex = g.x + e.ox + jitter;
        const ey = g.y + e.oy;
        const radius = e.isElite ? ENEMY_RADIUS * 1.6 : ENEMY_RADIUS;
        const hitThreshold = radius + 6;
        if (Math.hypot(ex - b.x, ey - b.y) < hitThreshold) {
          e.hp -= 10;
          if (!b.piercing) bullets.splice(bi,1);
          if (e.hp <= 0) { g.enemies.splice(ei,1); killCount++; killText.textContent = killCount; }
          hit = true;
          break;
        }
      }
    }
    if (hit) continue;
    if (boss && !boss.dead && Math.hypot(boss.x - b.x, boss.y - b.y) < boss.radius + 6) {
      boss.hp -= 10;
      if (!b.piercing) bullets.splice(bi,1);
      if (boss.hp <= 0) { boss.dead = true; spawnExplosion(boss.x, boss.y, "#ffcc66", 80); }
    }
  }

  // 弾と武器バーの当たり判定（ガード削り）
  for (let bi = bullets.length - 1; bi >= 0; bi--) {
    const b = bullets[bi];
    for (let ii = items.length - 1; ii >= 0; ii--) {
      const it = items[ii];
      if (it.type !== 'weapon') continue;
      if (b.x > it.x - 40 && b.x < it.x + 40 && Math.abs(b.y - it.y) < 15) {
        it.guard--;
        bullets.splice(bi,1);
        if (it.guard <= 0) {
          spawnLevelUpEffect(it.x, it.y, (!boss || boss.dead) ? "Level Up!" : "Shattered");
          if (!boss || boss.dead) upgradeWeapon();
          items.splice(ii,1);
        }
        break;
      }
    }
  }

  // particles update
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.06;
    p.life += dt;
    if (p.life >= p.ttl) particles.splice(i,1);
  }

  // floating texts update
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.life += dt;
    t.y += t.vy * dt;
    if (t.life >= t.ttl) floatingTexts.splice(i,1);
  }

  allyText.textContent = allies.length;
  killText.textContent = killCount;
}

/* ====== 描画 ====== */
function drawHuman(x,y,scale=1,color="#4caf50",gunColor="#333"){
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.arc(x, y - 18*scale, 8*scale, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = color; ctx.fillRect(x - 6*scale, y - 12*scale, 12*scale, 18*scale);
  ctx.fillRect(x - 14*scale, y - 10*scale, 8*scale, 4*scale);
  ctx.fillRect(x + 6*scale, y - 10*scale, 8*scale, 4*scale);
  ctx.fillRect(x - 8*scale, y + 6*scale, 4*scale, 10*scale);
  ctx.fillRect(x + 4*scale, y + 6*scale, 4*scale, 10*scale);
  ctx.fillStyle = gunColor; ctx.fillRect(x + 8*scale, y - 8*scale, 18*scale, 4*scale);
  ctx.fillRect(x + 6*scale, y - 10*scale, 6*scale, 6*scale);
}

function draw(){
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  ctx.fillStyle = "#151515"; ctx.fillRect(0,0,WIDTH,HEIGHT);

  // player
  drawHuman(player.x, player.y, 1.0, "#4caf50", "#222");

  // allies
  allies.forEach(a => drawHuman(a.x, a.y, 0.8, "#66bb6a", "#222"));

  // bullets
  bullets.forEach(b => {
    ctx.fillStyle = b.isAlly ? "#ffd" : "#ffeb3b";
    ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
  });

  // enemies
  enemyGroups.forEach(g => {
    g.enemies.forEach(e => {
      const jitter = Math.sin(elapsedTime * 2 + e.jitterPhase) * 3;
      const ex = g.x + e.ox + jitter;
      const ey = g.y + e.oy;
      if (e.isElite) {
        const pulse = 1 + 0.06 * Math.sin(elapsedTime * 6 + e.jitterPhase);
        const eliteRadius = ENEMY_RADIUS * 1.6 * pulse;
        ctx.beginPath(); ctx.fillStyle = "#ffd166"; ctx.arc(ex, ey, eliteRadius, 0, Math.PI*2); ctx.fill();
        ctx.lineWidth = 2; ctx.strokeStyle = "#ff8c42"; ctx.stroke();
        ctx.globalAlpha = 0.12; ctx.beginPath(); ctx.fillStyle = "#ffd166"; ctx.arc(ex, ey, eliteRadius + 6, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
      } else {
        ctx.beginPath(); ctx.fillStyle = "#e53935"; ctx.arc(ex, ey, ENEMY_RADIUS, 0, Math.PI*2); ctx.fill();
      }
    });
  });

  // boss
  if (boss && !boss.dead) {
    ctx.fillStyle = "#ff4444"; ctx.beginPath(); ctx.arc(boss.x, boss.y, boss.radius, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "#fff"; ctx.font = "18px sans-serif"; ctx.fillText("Boss HP: " + boss.hp, boss.x - 60, boss.y - boss.radius - 10);
  }

  // particles
  particles.forEach(p => {
    ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, 1 - p.life / p.ttl);
    ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
  });

  // floating texts
  floatingTexts.forEach(t => {
    const alpha = Math.max(0, 1 - t.life / t.ttl);
    ctx.globalAlpha = alpha; ctx.fillStyle = "#fff59d"; ctx.font = "18px sans-serif";
    ctx.fillText(t.text, t.x - (t.text.length * 5), t.y);
    ctx.globalAlpha = 1;
  });

  // items
  items.forEach(it => {
    if (it.type === 'weapon') {
      ctx.fillStyle = "#29b6f6"; ctx.fillRect(it.x - 40, it.y - 10, 80, 20);
      ctx.fillStyle = "#fff"; ctx.font = "14px sans-serif"; ctx.fillText("G:" + it.guard, it.x - 15, it.y + 5);
    } else {
      ctx.fillStyle = "#66ff66"; ctx.fillRect(it.x - 40, it.y - 10, 80, 20);
      ctx.fillStyle = "#000"; ctx.font = "16px sans-serif"; ctx.fillText("+" + it.value, it.x - 8, it.y + 6);
    }
  });

  // touch indicator（指を置いた位置を表示）
  if (touchIndicator) {
    ctx.globalAlpha = 0.28;
    ctx.fillStyle = "#88ccff";
    ctx.beginPath();
    ctx.arc(touchIndicator.x, touchIndicator.y, 28, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // HUD
  ctx.fillStyle = "#fff"; ctx.font = "14px sans-serif";
  ctx.fillText("HP: " + Math.max(0, Math.floor(player.hp)), 10, 18);
}

/* ====== メインループ ====== */
function gameLoop(now){
  const t = now || performance.now();
  const dt = Math.min((t - lastTime) / 1000, 0.05);
  lastTime = t;

  update(dt);
  draw();

  requestAnimationFrame(gameLoop);
}

/* ====== スタート ====== */
resetGame();
requestAnimationFrame((t) => { lastTime = t; gameLoop(t); });

</script>
</body>
</html>
