<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vertical Lane Survival - ハンドガン調整版</title>
<style>
  html,body { height:100%; margin:0; background:#0b0b0b; color:#fff; font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  #ui { width:480px; margin:12px auto 6px; display:flex; gap:8px; align-items:center; justify-content:space-between; }
  #game { display:block; margin:0 auto; background:#151515; border:4px solid #333; width:450px; height:800px; box-shadow:0 6px 18px rgba(0,0,0,0.6); }
  button { padding:6px 10px; background:#1f6feb; color:#fff; border:0; border-radius:6px; cursor:pointer; }
  .info { font-size:14px; color:#ddd; }
  #message { text-align:center; margin-top:8px; color:#ffd; min-height:20px; }
</style>
</head>
<body>
  <div id="ui">
    <div class="info">武器: <span id="weaponText">ハンドガン</span>　仲間: <span id="allyText">0</span>　Kill: <span id="killText">0</span></div>
    <div><button id="restartBtn">Restart</button></div>
  </div>
  <canvas id="game" width="450" height="800"></canvas>
  <div id="message"></div>

<script>
/* ====== 設定（ハンドガン遅め・中盤終盤出現率増加） ====== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const WIDTH = canvas.width, HEIGHT = canvas.height;

const killText = document.getElementById('killText');
const weaponText = document.getElementById('weaponText');
const allyText = document.getElementById('allyText');
const messageEl = document.getElementById('message');
const restartBtn = document.getElementById('restartBtn');

const PLAYER_SPEED = 4;
const PLAYER_RADIUS = 16;
// 弾はピクセル/秒で扱う（発射時に angle/speed を固定）
const BULLET_SPEED = 600;
let ENEMY_SPEED = 0.9;
const ITEM_SPEED = 0.55;
const ENEMY_RADIUS = 11;
const SURVIVE_TIME = 60; // 秒でボス出現

let keys = {};
let lastTime = performance.now();
let elapsedTime = 0;
let spawnTimerEnemy = 0;
let spawnTimerItem = 0;
let enemySpawnInterval = 0.9;
let itemSpawnInterval = 2.5;
let shootCooldown = 0;

let player;
let bullets = [];
let enemyGroups = [];
let items = [];
let allies = [];
let killCount = 0;
let isGameOver = false;
let boss = null;

let particles = [];
let floatingTexts = [];

// 初期武器はハンドガン（weapon の各種は 0）
let weapon = { shotgun: 0, assault: 0, laser: 0, missile: 0 };

/* ====== 初期化 ====== */
function resetGame() {
  player = { x: WIDTH/2, y: HEIGHT - 40, hp: 100, facing: -Math.PI/2 };
  bullets = [];
  enemyGroups = [];
  items = [];
  allies = [];
  boss = null;
  particles = [];
  floatingTexts = [];
  killCount = 0;
  elapsedTime = 0;
  spawnTimerEnemy = 0;
  spawnTimerItem = 0;
  shootCooldown = 0;
  isGameOver = false;
  weapon = { shotgun: 0, assault: 0, laser: 0, missile: 0 };
  killText.textContent = killCount;
  allyText.textContent = allies.length;
  weaponText.textContent = "ハンドガン";
  messageEl.textContent = "";
}
restartBtn.addEventListener('click', resetGame);
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

/* ====== 敵群れ生成（易しめ・安定化） ====== */
function spawnEnemyGroup() {
  // safety: limit total enemy count to avoid freeze
  const totalEnemies = enemyGroups.reduce((s,g)=>s+g.enemies.length,0);
  const TOTAL_ENEMY_CAP = 120;
  if (totalEnemies >= TOTAL_ENEMY_CAP) return;

  const progress = Math.min(elapsedTime / SURVIVE_TIME, 1);
  const growthDelay = 0.45;
  const p = progress <= growthDelay ? 0 : (progress - growthDelay) / (1 - growthDelay);

  // band width
  const bandMin = 0.30, bandMax = 0.90;
  const bandWidth = WIDTH * (bandMin + (bandMax - bandMin) * Math.pow(progress, 1.2));
  const bandStart = Math.random() * Math.max(0, WIDTH - bandWidth);
  let centerX = bandStart + bandWidth / 2;

  const edgeMargin = Math.max(44, ENEMY_RADIUS * 2);
  centerX = Math.min(Math.max(centerX, edgeMargin), WIDTH - edgeMargin);

  const group = { x: centerX, y: -40, enemies: [] };

  // base count
  const baseMin = 2, baseMax = 4;
  const raw = baseMin + Math.floor(Math.random() * (baseMax - baseMin + 1));

  // scale with cap (中盤終盤でやや多めに)
  const maxMultiplier = 4.5; // 少し増やす（中盤終盤の出現率を増やす）
  const scale = 0.3 + Math.pow(p, 1.2) * (maxMultiplier - 0.3);
  const maxCountCap = 14;
  const count = Math.min(maxCountCap, Math.max(1, Math.floor(raw * scale)));

  // hp scale (控えめ)
  const baseEnemyHPMin = 6, baseEnemyHPMax = 12;
  const hpScale = 1 + p * 1.0;

  // radius bounds
  const rMinStart = 6, rMaxStart = 10;
  const rMinEnd = 20, rMaxEnd = Math.min(WIDTH * 0.4, 90);
  const rMin = rMinStart + (rMinEnd - rMinStart) * progress;
  const rMax = rMaxStart + (rMaxEnd - rMaxStart) * progress;

  const localMargin = 12;

  for (let i=0;i<count;i++){
    const r = rMin + Math.random() * (rMax - rMin);
    const ang = Math.random() * Math.PI * 2;
    let ox = Math.cos(ang) * r;
    let oy = Math.sin(ang) * r;

    // clamp horizontally
    const minOx = edgeMargin - group.x + localMargin;
    const maxOx = (WIDTH - edgeMargin) - group.x - localMargin;
    ox = Math.min(Math.max(ox, minOx), maxOx);

    const baseHP = baseEnemyHPMin + Math.floor(Math.random() * (baseEnemyHPMax - baseEnemyHPMin + 1));
    const hp = Math.max(1, Math.floor(baseHP * hpScale));
    group.enemies.push({ ox, oy, jitterPhase: Math.random() * Math.PI * 2, hp });
  }

  // elites: 低め
  let eliteChance = 0;
  if (p > 0) eliteChance = 0.02 + Math.pow(p, 1.2) * 0.08;
  const maxElitePerGroup = 1;
  if (Math.random() < eliteChance) {
    const extra = Math.min(maxElitePerGroup, 1 + Math.floor(p * 1));
    for (let k=0;k<extra;k++){
      const ox = (Math.random()-0.5) * Math.min(bandWidth, 200);
      const oy = (Math.random()-0.5) * Math.min(rMax, 120);
      const clampedOx = Math.min(Math.max(ox, edgeMargin - group.x + localMargin), (WIDTH - edgeMargin) - group.x - localMargin);
      const eliteBase = 160 + Math.random() * 80;
      const eliteHp = Math.floor(eliteBase * (1 + p * 0.6));
      group.enemies.push({ ox: clampedOx, oy, jitterPhase: Math.random() * Math.PI * 2, hp: eliteHp, isElite: true });
    }
  }

  // ensure topmost enemy spawns above screen
  let minOy = Infinity;
  for (const e of group.enemies) if (e.oy < minOy) minOy = e.oy;
  const spawnOffset = 18;
  group.y = -spawnOffset - minOy;

  group.x = Math.min(Math.max(group.x, edgeMargin), WIDTH - edgeMargin);

  enemyGroups.push(group);
}

/* ====== ボス生成（既存アイテムは消さない） ====== */
function spawnBoss() {
  boss = {
    x: WIDTH/2,
    y: -120,
    hp: 22000 + Math.floor(Math.random()*6000),
    speed: 0.5,
    radius: 56,
    dead: false,
    deathTimer: 0
  };
}

/* ====== アイテム生成（仲間速度に統一） ====== */
function spawnItem() {
  if (boss && !boss.dead) return;

  const edgeMargin = 40;
  const x = Math.min(Math.max(Math.random() * WIDTH, edgeMargin), WIDTH - edgeMargin);
  const progress = Math.min(elapsedTime / SURVIVE_TIME, 1);
  const allyProb = 0.40;
  const baseItemSpeed = ITEM_SPEED;

  if (Math.random() < allyProb) {
    const value = Math.random() < 0.25 ? 2 : 1;
    items.push({ x, y: -20, type: "ally", value, speed: baseItemSpeed });
    return;
  }

  // weapon guard scaling (控えめ)
  const growthDelay = 0.6;
  const p = progress <= growthDelay ? 0 : (progress - growthDelay) / (1 - growthDelay);
  const guardMin = 6, guardMid = 40, guardMax = 180;
  let guard;
  if (p <= 0) guard = guardMin + Math.floor(Math.random()*3);
  else if (p < 0.6) {
    const t = p / 0.6;
    guard = Math.floor(guardMin + Math.pow(t, 1.8) * (guardMid - guardMin));
  } else {
    const t = (p - 0.6) / 0.4;
    guard = Math.floor(guardMid + Math.pow(t, 1.4) * (guardMax - guardMid));
  }

  items.push({ x, y: -20, type: "weapon", guard, speed: baseItemSpeed });
}

/* ====== 武器強化（B方式） ====== */
function upgradeWeapon() {
  const roll = Math.random();
  if (roll < 0.25) { weapon.shotgun++; weaponText.textContent = "ショットガン Lv" + weapon.shotgun; }
  else if (roll < 0.5) { weapon.assault++; weaponText.textContent = "アサルト Lv" + weapon.assault; }
  else if (roll < 0.75) { weapon.laser++; weaponText.textContent = "レーザー Lv" + weapon.laser; }
  else { weapon.missile++; weaponText.textContent = "ミサイル Lv" + weapon.missile; }
}

/* ====== 発射（角度/速度固定で直進） ====== */
function computeGunTip(x,y,facing,ownerRadius){
  const offset = ownerRadius + 8;
  return { tx: x + Math.cos(facing)*offset, ty: y + Math.sin(facing)*offset };
}
function shootPlayer(x,y){
  const facing = player.facing || -Math.PI/2;
  const tip = computeGunTip(x, y-6, facing, PLAYER_RADIUS);
  const speed = BULLET_SPEED;
  const piercing = weapon.laser > 0;
  const count = 1 + weapon.shotgun * 2;
  for (let i=0;i<count;i++){
    const angle = facing;
    bullets.push({
      x: tip.tx, y: tip.ty,
      angle: angle, speed: speed,
      piercing, isAlly:false,
      createdAt: performance.now(), life: 4200
    });
  }
}
function shootAlly(a){
  const facing = -Math.PI/2;
  const tip = computeGunTip(a.x, a.y-4, facing, 10);
  bullets.push({
    x: tip.tx, y: tip.ty,
    angle: facing, speed: BULLET_SPEED * 0.7,
    piercing:false, isAlly:true,
    createdAt: performance.now(), life: 3200
  });
}

/* ====== 仲間更新 ====== */
function updateAllies(){
  const colWidth = 36;
  const maxPerRow = 6;
  allies.forEach((a,i)=>{
    const col = i % maxPerRow;
    const row = Math.floor(i / maxPerRow);
    const totalCols = Math.min(allies.length - row * maxPerRow, maxPerRow);
    const startX = player.x - (totalCols - 1) * colWidth / 2;
    const targetX = startX + col * colWidth;
    const targetY = player.y + 40 + row * 30;
    a.x += (targetX - a.x) * 0.22;
    a.y += (targetY - a.y) * 0.22;
    if (Math.random() < 0.02) shootAlly(a);
  });
}

/* ====== 爆発パーティクル ====== */
function spawnExplosion(x,y,color="#ffcc66",count=40){
  for (let i=0;i<count;i++){
    const ang = Math.random()*Math.PI*2;
    const speed = 1 + Math.random()*4;
    particles.push({ x,y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, life:0, ttl:0.8 + Math.random()*0.6, color });
  }
}

/* ====== レベルアップ演出 ====== */
function spawnLevelUpEffect(x,y,text="Level Up!"){
  spawnExplosion(x,y,"#ffd166",14);
  floatingTexts.push({ x, y, text, life:0, ttl:1.2, vy:-30 });
}

/* ====== 敵が下ラインに到達したら敗北判定 ====== */
function checkEnemyReachedBottom(){
  const bottomLine = HEIGHT - 90;
  for (const g of enemyGroups){
    for (const e of g.enemies){
      const ey = g.y + e.oy;
      if (ey > bottomLine) return true;
    }
  }
  return false;
}

/* ====== 更新 ====== */
function update(dt){
  if (isGameOver) return;

  // clamp dt to avoid huge jumps
  dt = Math.min(dt, 0.05);
  elapsedTime += dt;

  const progress = Math.min(elapsedTime / SURVIVE_TIME, 1);
  const growthDelay = 0.5;
  const p = progress <= growthDelay ? 0 : (progress - growthDelay) / (1 - growthDelay);

  // spawn interval: 初期はゆったり、中盤終盤は増やす（最小を下げて出現率増）
  enemySpawnInterval = p === 0 ? 1.2 : Math.max(0.35, 1.2 - Math.pow(p, 1.0) * 1.0);

  // enemy speed scales mildly but capped
  const enemySpeed = ENEMY_SPEED + p * 0.35;

  // boss spawn
  if (!boss && elapsedTime >= SURVIVE_TIME) spawnBoss();

  // boss death handling
  if (boss && boss.dead) {
    boss.deathTimer += dt;
    if (boss.deathTimer < 0.6 && Math.random() < 0.2) {
      spawnExplosion(boss.x + (Math.random()-0.5)*boss.radius, boss.y + (Math.random()-0.5)*boss.radius, "#ff6666", 6);
    }
    if (boss.deathTimer >= 1.2) {
      isGameOver = true;
      messageEl.textContent = "ボス撃破！クリア！";
    }
  }

  // spawn enemy groups if not boss
  if (!boss) {
    spawnTimerEnemy += dt;
    if (spawnTimerEnemy >= enemySpawnInterval) {
      spawnTimerEnemy = 0;
      spawnEnemyGroup();
    }
  }

  // spawn items
  spawnTimerItem += dt;
  if (spawnTimerItem >= itemSpawnInterval) {
    spawnTimerItem = 0;
    spawnItem();
  }

  // player movement
  if (keys['a'] || keys['arrowleft']) { player.x -= PLAYER_SPEED; player.facing = -Math.PI/2 - 0.25; }
  if (keys['d'] || keys['arrowright']) { player.x += PLAYER_SPEED; player.facing = -Math.PI/2 + 0.25; }
  if (!keys['a'] && !keys['d']) player.facing = -Math.PI/2;
  player.x = Math.max(PLAYER_RADIUS, Math.min(WIDTH - PLAYER_RADIUS, player.x));

  // auto shooting: ハンドガン初期は発射間隔を遅めに（ユーザー要望でさらに遅く）
  shootCooldown -= dt;
  let interval = 0.45 - weapon.assault * 0.03; // 基本0.45s（遅め）
  if (interval < 0.12) interval = 0.12;
  if (shootCooldown <= 0) {
    shootPlayer(player.x, player.y);
    shootCooldown = interval;
  }

  updateAllies();

  // bullets update (angle/speed fixed)
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += Math.cos(b.angle) * b.speed * dt;
    b.y += Math.sin(b.angle) * b.speed * dt;
    if (b.createdAt && b.life && (performance.now() - b.createdAt > b.life)) { bullets.splice(i,1); continue; }
    if (b.y < -80 || b.y > HEIGHT + 80 || b.x < -80 || b.x > WIDTH + 80) bullets.splice(i,1);
  }

  // enemy groups update
  for (let gi = enemyGroups.length - 1; gi >= 0; gi--) {
    const g = enemyGroups[gi];
    g.y += enemySpeed;
    for (let ei = g.enemies.length - 1; ei >= 0; ei--) {
      const e = g.enemies[ei];
      const jitter = Math.sin(elapsedTime * 2 + e.jitterPhase) * 2;
      const ex = g.x + e.ox + jitter;
      const ey = g.y + e.oy;
      if (Math.hypot(player.x - ex, player.y - ey) < PLAYER_RADIUS + ENEMY_RADIUS) {
        player.hp -= 20 * dt;
        if (player.hp <= 0) { isGameOver = true; messageEl.textContent = "ゲームオーバー"; }
      }
    }
    if (g.y > HEIGHT + 120 || g.enemies.length === 0) enemyGroups.splice(gi,1);
  }

  // check bottom reach
  if (checkEnemyReachedBottom()) {
    isGameOver = true;
    messageEl.textContent = "敵が到達しました…ゲームオーバー";
    return;
  }

  // boss update
  if (boss && !boss.dead) {
    boss.y += boss.speed;
    if (Math.hypot(player.x - boss.x, player.y - boss.y) < PLAYER_RADIUS + boss.radius) {
      player.hp -= 30 * dt;
      if (player.hp <= 0) { isGameOver = true; messageEl.textContent = "ゲームオーバー"; }
    }
  }

  // items update
  for (let i = items.length - 1; i >= 0; i--) {
    const it = items[i];
    const s = (typeof it.speed === 'number') ? it.speed : ITEM_SPEED;
    it.y += s;
    if (it.type === 'ally') {
      if (Math.abs(player.x - it.x) < 40 && Math.abs(player.y - it.y) < 20) {
        for (let n=0;n<it.value;n++){
          allies.push({ x: player.x + (Math.random()-0.5)*10, y: player.y + 40 + Math.random()*6 });
        }
        allyText.textContent = allies.length;
        items.splice(i,1);
        continue;
      }
    }
    if (it.y > HEIGHT + 80) items.splice(i,1);
  }

  // bullets vs enemies & boss
  for (let bi = bullets.length - 1; bi >= 0; bi--) {
    const b = bullets[bi];
    let hit = false;
    for (let gi = 0; gi < enemyGroups.length && !hit; gi++) {
      const g = enemyGroups[gi];
      for (let ei = g.enemies.length - 1; ei >= 0; ei--) {
        const e = g.enemies[ei];
        const jitter = Math.sin(elapsedTime * 2 + e.jitterPhase) * 2;
        const ex = g.x + e.ox + jitter;
        const ey = g.y + e.oy;
        const radius = e.isElite ? ENEMY_RADIUS * 1.6 : ENEMY_RADIUS;
        const hitThreshold = radius + 6;
        if (Math.hypot(ex - b.x, ey - b.y) < hitThreshold) {
          e.hp -= 10;
          if (!b.piercing) bullets.splice(bi,1);
          if (e.hp <= 0) { g.enemies.splice(ei,1); killCount++; killText.textContent = killCount; }
          hit = true;
          break;
        }
      }
    }
    if (hit) continue;
    if (boss && !boss.dead && Math.hypot(boss.x - b.x, boss.y - b.y) < boss.radius + 6) {
      boss.hp -= 10;
      if (!b.piercing) bullets.splice(bi,1);
      if (boss.hp <= 0) { boss.dead = true; spawnExplosion(boss.x, boss.y, "#ffcc66", 80); }
    }
  }

  // bullets vs weapon bars (guard)
  for (let bi = bullets.length - 1; bi >= 0; bi--) {
    const b = bullets[bi];
    for (let ii = items.length - 1; ii >= 0; ii--) {
      const it = items[ii];
      if (it.type !== 'weapon') continue;
      if (b.x > it.x - 40 && b.x < it.x + 40 && Math.abs(b.y - it.y) < 15) {
        it.guard--;
        bullets.splice(bi,1);
        if (it.guard <= 0) {
          spawnLevelUpEffect(it.x, it.y, (!boss || boss.dead) ? "Level Up!" : "Shattered");
          if (!boss || boss.dead) upgradeWeapon();
          items.splice(ii,1);
        }
        break;
      }
    }
  }

  // particles update
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.06;
    p.life += dt;
    if (p.life >= p.ttl) particles.splice(i,1);
  }

  // floating texts update
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.life += dt;
    t.y += t.vy * dt;
    if (t.life >= t.ttl) floatingTexts.splice(i,1);
  }

  // UI
  allyText.textContent = allies.length;
  killText.textContent = killCount;
}

/* ====== 描画 ====== */
function drawHuman(x,y,scale=1,color="#4caf50",gunColor="#333"){
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.arc(x, y - 18*scale, 8*scale, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = color; ctx.fillRect(x - 6*scale, y - 12*scale, 12*scale, 18*scale);
  ctx.fillRect(x - 14*scale, y - 10*scale, 8*scale, 4*scale);
  ctx.fillRect(x + 6*scale, y - 10*scale, 8*scale, 4*scale);
  ctx.fillRect(x - 8*scale, y + 6*scale, 4*scale, 10*scale);
  ctx.fillRect(x + 4*scale, y + 6*scale, 4*scale, 10*scale);
  ctx.fillStyle = gunColor; ctx.fillRect(x + 8*scale, y - 8*scale, 18*scale, 4*scale);
  ctx.fillRect(x + 6*scale, y - 10*scale, 6*scale, 6*scale);
}

function draw(){
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  ctx.fillStyle = "#151515"; ctx.fillRect(0,0,WIDTH,HEIGHT);

  // player
  drawHuman(player.x, player.y, 1.0, "#4caf50", "#222");

  // allies
  allies.forEach(a => drawHuman(a.x, a.y, 0.8, "#66bb6a", "#222"));

  // bullets
  bullets.forEach(b => {
    ctx.fillStyle = b.isAlly ? "#ffd" : "#ffeb3b";
    ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
  });

  // enemies
  enemyGroups.forEach(g => {
    g.enemies.forEach(e => {
      const jitter = Math.sin(elapsedTime * 2 + e.jitterPhase) * 3;
      const ex = g.x + e.ox + jitter;
      const ey = g.y + e.oy;
      if (e.isElite) {
        const pulse = 1 + 0.06 * Math.sin(elapsedTime * 6 + e.jitterPhase);
        const eliteRadius = ENEMY_RADIUS * 1.6 * pulse;
        ctx.beginPath(); ctx.fillStyle = "#ffd166"; ctx.arc(ex, ey, eliteRadius, 0, Math.PI*2); ctx.fill();
        ctx.lineWidth = 2; ctx.strokeStyle = "#ff8c42"; ctx.stroke();
        ctx.globalAlpha = 0.12; ctx.beginPath(); ctx.fillStyle = "#ffd166"; ctx.arc(ex, ey, eliteRadius + 6, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
      } else {
        ctx.beginPath(); ctx.fillStyle = "#e53935"; ctx.arc(ex, ey, ENEMY_RADIUS, 0, Math.PI*2); ctx.fill();
      }
    });
  });

  // boss
  if (boss && !boss.dead) {
    ctx.fillStyle = "#ff4444"; ctx.beginPath(); ctx.arc(boss.x, boss.y, boss.radius, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "#fff"; ctx.font = "18px sans-serif"; ctx.fillText("Boss HP: " + boss.hp, boss.x - 60, boss.y - boss.radius - 10);
  }

  // particles
  particles.forEach(p => {
    ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, 1 - p.life / p.ttl);
    ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
  });

  // floating texts
  floatingTexts.forEach(t => {
    const alpha = Math.max(0, 1 - t.life / t.ttl);
    ctx.globalAlpha = alpha; ctx.fillStyle = "#fff59d"; ctx.font = "18px sans-serif";
    ctx.fillText(t.text, t.x - (t.text.length * 5), t.y);
    ctx.globalAlpha = 1;
  });

  // items
  items.forEach(it => {
    if (it.type === 'weapon') {
      ctx.fillStyle = "#29b6f6"; ctx.fillRect(it.x - 40, it.y - 10, 80, 20);
      ctx.fillStyle = "#fff"; ctx.font = "14px sans-serif"; ctx.fillText("G:" + it.guard, it.x - 15, it.y + 5);
    } else {
      ctx.fillStyle = "#66ff66"; ctx.fillRect(it.x - 40, it.y - 10, 80, 20);
      ctx.fillStyle = "#000"; ctx.font = "16px sans-serif"; ctx.fillText("+" + it.value, it.x - 8, it.y + 6);
    }
  });

  // HUD: player HP
  ctx.fillStyle = "#fff"; ctx.font = "14px sans-serif";
  ctx.fillText("HP: " + Math.max(0, Math.floor(player.hp)), 10, 18);
}

/* ====== メインループ ====== */
function gameLoop(now){
  const t = now || performance.now();
  const dt = Math.min((t - lastTime) / 1000, 0.05);
  lastTime = t;

  update(dt);
  draw();

  requestAnimationFrame(gameLoop);
}

/* ====== スタート ====== */
resetGame();
requestAnimationFrame((t) => { lastTime = t; gameLoop(t); });

</script>
</body>
</html>